## 宿題1

- 行列積のループ順序としては6種類の組合せがある。この6種類を実行速度が速いと思う方から順に並べてください。実際に実験してその予想が正しいかどうか確かめてください。
- i-j-k, i-k-j, j-i-k, j-k-i, k-i-j, k-j-i


### 実行時間
|  | 予想 | 結果 | N=1000 |
| --- | --- | --- | --- |
| 1 | i-k-j | i-k-j | 3.157722 |
| 2 | k-i-j | k-i-j | 3.194846 |
| 3 | i-j-k | j-i-k | 4.780624 |
| 4 | j-i-k | k-j-i | 9.576106 |
| 5 | j-k-i | i-j-k | 9.694399 |
| 6 | k-j-i | j-k-i | 13.771865 |


## 宿題2

- C/C++/Java/Goで行列積を書くと、i-k-jループのほうがi-j-kループよりもずっと速かった。実はPythonで書くと、ループ順序を入れ替えても速度差はほとんどない。ここまでの説明をふまえて、その理由を考えてください。

Pythonはインタプリタで、与えられたプログラムの字句解析、構文解析を行い、構文木を作る。
ループ順序を替えるとできあがる構文木は異なるが、構文木は最適化されず、
キャッシュヒット率の高さによる高速化よりも構文木をたどる時間の影響で、速度差はほとんど生まれない。


## 宿題3

### Greedy法 + 2-opt法
- 以下を改善ができなくなるまで繰り返す
  - 適当な都市aを選び、巡回路でaの次の都市をbとする
  - 都市aの近傍N都市からa, b以外の都市cと、巡回路でcの次の都市dを選ぶ
  - ab+cd > ac+bd であれば辺ab, cdをac, bdに入れ替える
